import subprocess
import tempfile
from typing import List, Optional, Tuple

import black
import mypy.api


def black_format_code(code: str) -> Tuple[str, Optional[str]]:
    """Format code using black."""
    error_str: Optional[str] = None
    formatted_code: str = ""
    try:
        formatted_code = black.format_str(code, mode=black.FileMode())
    except Exception as error:
        formatted_code = code
        error_str = str(error)
    return formatted_code, error_str


def run_mypy(code: str) -> Tuple[str, str, int]:
    """
    Run mypy (static type checker) on code.

    Returns:
        stdout (str): output of mypy, errors found etc
        stderr (str): errors generated by mypy itself
        exit_code (int): 0 means no type errors, non-zero implies type errors
    """
    return mypy.api.run(
        [
            "--ignore-missing-imports",
            "--no-namespace-packages",
            "--follow_imports",
            "silent",
            "-c",
            code,
        ]
    )


def run_flake8(code: str) -> Tuple[str, str]:
    """
    Run flake8 (linter) on code.

    Returns:
        stdout (str): output of flake8, errors found etc
        stderr (str): errors generated by flake8 itself
    """
    with tempfile.NamedTemporaryFile(suffix=".py", mode="w", delete=True) as temp_file:
        temp_file.write(code)
        temp_file.flush()  # Make sure all data is flushed to disk
        result = subprocess.run(
            ["flake8", temp_file.name], capture_output=True, text=True
        )

    return result.stdout, result.stderr


class CodeAnalysisError:
    """Represents a code analysis error."""

    def __init__(
        self, code_ref: str, line_num: int, error: str, prefix: str = "CodeAnalysis"
    ):
        self.code_ref = code_ref
        self.line_num = line_num
        self.error = error
        self.prefix = prefix

    def __repr__(self) -> str:
        return f'{self.prefix}Error(code_ref="{self.code_ref}", line_num={self.line_num}, error="{self.error}")'


class TypeCheckingError(CodeAnalysisError):
    """Represents a type checking error."""

    def __init__(self, code_ref: str, line_num: int, error: str):
        super().__init__(code_ref, line_num, error, prefix="TypeChecking")


class LintingError(CodeAnalysisError):
    """Represents a linting error."""

    def __init__(self, code_ref: str, line_num: int, error: str):
        super().__init__(code_ref, line_num, error, prefix="Linting")


def parse_mypy_output(mypy_output: str, code: str) -> List[TypeCheckingError]:
    """Parse mypy output."""
    if mypy_output == "":
        return []

    code_lines = code.split("\n")
    parse = []
    # skip last two items after split because - the second last is a count of error &
    # the last is an empty string
    lines = mypy_output.split("\n")
    assert lines[-2].startswith("Found ") or lines[-2].startswith("Success")
    assert lines[-1] == ""
    for line in lines[:-2]:
        path, line_num, error_type, error = line.split(":", maxsplit=3)
        parse.append(
            TypeCheckingError(
                code_ref=code_lines[int(line_num) - 1],
                line_num=int(line_num),
                error=error.strip(),
            )
        )

    return parse


def parse_flake8_output(flake8_output: str, code: str) -> List[LintingError]:
    """Parse flake8 output."""
    if parse_flake8_output == "":
        return []

    code_lines = code.split("\n")
    parse = []
    # skip last item after split because it's an empty string
    lines = flake8_output.split("\n")
    assert lines[-1] == ""
    for line in lines[:-1]:
        path, line_num, col, error = line.split(":", maxsplit=3)
        parse.append(
            LintingError(
                code_ref=code_lines[int(line_num) - 1],
                line_num=int(line_num),
                error=error.strip(),
            )
        )

    return parse


def get_linting_errors(
    code: str, skip_codes: List[str] = ["E402", "E501"]
) -> List[LintingError]:
    """Get linting errors."""
    lint_errs = parse_flake8_output(run_flake8(code)[0], code)
    to_return: List[LintingError] = []
    for err in lint_errs:
        if not any([code in err.error for code in skip_codes]):
            to_return.append(err)

    return to_return


def get_type_checking_errors(code: str) -> List[TypeCheckingError]:
    """Get type checking errors."""
    type_errs = parse_mypy_output(run_mypy(code)[0], code)
    to_return: List[TypeCheckingError] = []
    for err in type_errs:
        if "no-redef" not in err.error:
            to_return.append(err)

    return to_return
